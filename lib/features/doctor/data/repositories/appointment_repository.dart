import 'package:drift/drift.dart';
import '../../../../core/database/app_database.dart';

import '../../../../core/error/error_handler.dart';
import '../../../../core/sync/sync_manager.dart';
import '../../../../core/sync/sync_queue_state_machine.dart';
import '../../models/appointment_model.dart';
// Note: AppointmentEntity should be generated by Drift from 'Appointments' table

class AppointmentRepository {
  final AppDatabase _db;
  final SyncManager _syncManager;

  AppointmentRepository({
    required AppDatabase db,
    required SyncManager syncManager,
  })  : _db = db,
        _syncManager = syncManager;

  /// Create Appointment
  Future<void> createAppointment(AppointmentModel appointment) async {
    try {
      await _db.into(_db.appointments).insert(
            AppointmentsCompanion.insert(
              id: appointment.id,
              doctorId: appointment.doctorId,
              patientId: appointment.patientId,
              scheduledTime: appointment.scheduledTime,
              status: Value(appointment.status.name),
              purpose: Value(appointment.purpose),
              notes: Value(appointment.notes),
              createdAt: appointment.createdAt,
              updatedAt: appointment.updatedAt,
            ),
          );

      await _syncManager.enqueue(SyncQueueItem.create(
        userId:
            'SYSTEM', // Should be doctor/vendor ID ideally but we use SYSTEM or from session
        operationType: SyncOperationType.create,
        targetCollection: 'appointments',
        documentId: appointment.id,
        payload: appointment.toMap(),
        priority: 1,
      ));
    } catch (e, stack) {
      ErrorHandler.handle(e,
          stackTrace: stack, userMessage: 'Failed to create appointment');
      rethrow;
    }
  }

  /// Update Appointment
  Future<void> updateAppointment(AppointmentModel appointment) async {
    try {
      await (_db.update(_db.appointments)
            ..where((t) => t.id.equals(appointment.id)))
          .write(AppointmentsCompanion(
        scheduledTime: Value(appointment.scheduledTime),
        status: Value(appointment.status.name),
        purpose: Value(appointment.purpose),
        notes: Value(appointment.notes),
        updatedAt: Value(DateTime.now()),
      ));

      await _syncManager.enqueue(SyncQueueItem.create(
        userId: 'SYSTEM',
        operationType: SyncOperationType.update,
        targetCollection: 'appointments',
        documentId: appointment.id,
        payload: appointment.toMap(),
        priority: 1,
      ));
    } catch (e, stack) {
      ErrorHandler.handle(e,
          stackTrace: stack, userMessage: 'Failed to update appointment');
      rethrow;
    }
  }

  /// Get Appointments for Doctor (by Date Range)
  Future<List<AppointmentModel>> getAppointmentsForDoctor(
      String doctorId, DateTime start, DateTime end) async {
    final rows = await (_db.select(_db.appointments)
          ..where((t) =>
              t.doctorId.equals(doctorId) &
              t.scheduledTime.isBiggerOrEqualValue(start) &
              t.scheduledTime.isSmallerOrEqualValue(end))
          ..orderBy([(t) => OrderingTerm.asc(t.scheduledTime)]))
        .get();
    return rows.map((row) => _mapToModel(row)).toList();
  }

  /// Watch Appointments for Doctor (Reactive)
  Stream<List<AppointmentModel>> watchAppointmentsForDoctor(
      String doctorId, DateTime date) {
    // Filter for the specific day
    final startOfDay = DateTime(date.year, date.month, date.day);
    final endOfDay = startOfDay.add(const Duration(days: 1));

    return (_db.select(_db.appointments)
          ..where((t) =>
              t.doctorId.equals(doctorId) &
              t.scheduledTime.isBiggerOrEqualValue(startOfDay) &
              t.scheduledTime.isSmallerThanValue(endOfDay))
          ..orderBy([(t) => OrderingTerm.asc(t.scheduledTime)]))
        .watch()
        .map((rows) => rows.map((row) => _mapToModel(row)).toList());
  }

  /// Watch Appointments for Patient (Reactive)
  Stream<List<AppointmentModel>> watchAppointmentsForPatient(String patientId) {
    return (_db.select(_db.appointments)
          ..where((t) => t.patientId.equals(patientId))
          ..orderBy([(t) => OrderingTerm.asc(t.scheduledTime)]))
        .watch()
        .map((rows) => rows.map((row) => _mapToModel(row)).toList());
  }

  AppointmentModel _mapToModel(AppointmentEntity row) {
    return AppointmentModel(
      id: row.id,
      doctorId: row.doctorId,
      patientId: row.patientId,
      scheduledTime: row.scheduledTime,
      status: AppointmentStatus.values.firstWhere(
        (e) => e.name == row.status,
        orElse: () => AppointmentStatus.scheduled,
      ),
      purpose: row.purpose,
      notes: row.notes,
      createdAt: row.createdAt,
      updatedAt: row.updatedAt,
    );
  }
}
